# My TypeScript Journey: Earned Badges üèÜ

## Badges Overview

Here is a collection of badges I earned from completing Microsoft Learn's TypeScript modules:

1. **Getting Started with TypeScript**: [Badge](https://learn.microsoft.com/api/achievements/share/en-us/alv0425/8R645S6W?sharingId=31EA8433DACC585)
2. **Declare Variable Types in TypeScript**: [Badge](https://learn.microsoft.com/api/achievements/share/en-us/alv0425/EJ7HBSMP?sharingId=31EA8433DACC585)
3. **Implement Interfaces in TypeScript**: [Badge](https://learn.microsoft.com/api/achievements/share/en-us/alv0425/N79TX2HF?sharingId=31EA8433DACC585)
4. **Develop Typed Functions in TypeScript**: [Badge](https://learn.microsoft.com/api/achievements/share/en-us/alv0425/EJ7WNN2P?sharingId=31EA8433DACC585)
5. **Declare and Instantiate Classes in TypeScript**: [Badge](https://learn.microsoft.com/api/achievements/share/en-us/alv0425/9NST8L2U?sharingId=31EA8433DACC585)
6. **Generics in TypeScript**: [Badge]()
7. **Work with External Libraries in TypeScript**: [Badge]()
8. **Organize Code with Namespaces in TypeScript**: [Badge]()

## Reflections

1. In the first module, I discovered the benefits of using the TypeScript language and why it was created. I installed and configured the TypeScript development environment in VSCode. TypeScript provides flexible configuration with a wide variety of options. With TypeScript, you can specify the target ECMAScript version, enable strict type checking, and customize the compilation process to suit your project's needs.

2. In the second module, I learned about declaring typed variables, working with typed objects, and the concepts of type unions and intersections. Type assertions in TypeScript allow you to override the inferred type of variable and assert that it has a specific type. This can be useful when you know more about the variable's type than TypeScript can infer. I also learned about type guards, which perform runtime checks to narrow down the type of variable based on specific conditions. Type guards are especially helpful when working with union types, allowing you to write code that can differentiate between different types within the union. This can be very useful for handling different behaviors or properties specific to each type within the union. I also discovered the enum type, which allows defining a set of named constants. Enums can be a great way to improve code readability and maintainability by providing meaningful names for different values that may otherwise be represented by values of various types. 

3. In the next module I learned the interfaces in TypeScript. Interfaces in TypeScript provide a way to define the structure of objects, including their properties and methods and their types. They can be used to enforce a contract on objects and ensure that they adhere to a specific shape. Interfaces also allow for the creation of complex types by combining other types, such as other interfaces or primitive types. This can help to create more flexible and reusable code by defining custom types that can be used across different parts of an application. 

4. I also discovered typed functions in TypeScript. This helps to ensure that the function is used correctly and can catch potential type errors at compile-time. Additionally, TypeScript allows for the use of optional and default parameters in functions, providing more flexibility in how the functions are called. I think that one can benefit from using function overloading here to declare multiple signatures for a single function, allowing to perform different operations based on input types.

5. I learned the principles of class typing in TypeScript and practiced using interfaces and classes to define the shape and behavior of objects in my code. This will help me create more structured and maintainable applications. I used TypeScript's inheritance support to create class hierarchies and improve code reusability and modularity.  In addition, I experimented with TypeScript's access modifiers like public, private, and protected to manage the visibility and accessibility of properties and methods. By encapsulating certain properties and methods, one can ensure the integrity and security of code.

